package ygodb.windows.importer;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import ygodb.commonlibrary.bean.CardSet;
import ygodb.commonlibrary.bean.GamePlayCard;
import ygodb.commonlibrary.bean.OwnedCard;
import ygodb.commonlibrary.connection.DatabaseHashMap;
import ygodb.commonlibrary.connection.SQLiteConnection;
import ygodb.commonlibrary.constant.Const;
import ygodb.commonlibrary.utility.Util;
import ygodb.commonlibrary.utility.YGOLogger;
import ygodb.windows.utility.WindowsUtil;

import java.io.FileWriter;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ImportPricesFromYGOPROAPI {

	private static final String OPEN = "\"";
	private static final String CLOSE = "\",";
	private static final String SEP = "\",\"";

	private final HashMap<String, List<String>> nameUpdateMap = new HashMap<>();

	private final HashSet<String> updatedKeysSet = new HashSet<>();
	private final HashMap<String, Integer> updatedMoreThanOnceKeysMap = new HashMap<>();

	private final Map<String, Set<String>> updatedKeysMap = new HashMap<>();

	public static void main(String[] args) throws SQLException, IOException {
		ImportPricesFromYGOPROAPI mainObj = new ImportPricesFromYGOPROAPI();

		SQLiteConnection db = WindowsUtil.getDBInstance();

		boolean successful = mainObj.run(db);
		if (!successful) {
			YGOLogger.info("Import Failed");
		} else {
			YGOLogger.info("Import Finished");
		}
		db.closeInstance();
	}

	public boolean run(SQLiteConnection db) throws SQLException, IOException {

		String setAPI = "https://db.ygoprodeck.com/api/v7/cardinfo.php?tcgplayer_data=true";

		try {

			URL url = new URL(setAPI);

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.connect();

			// Getting the response code
			int responseCode = conn.getResponseCode();

			if (responseCode != 200) {
				YGOLogger.error("HttpResponseCode: " + responseCode);
				return false;
			} else {

				String inline = Util.getApiResponseFromURL(url);

				ObjectMapper objectMapper = new ObjectMapper();
				JsonNode jsonNode = objectMapper.readTree(inline);

				try (FileWriter writer = new FileWriter("C:\\Users\\Mike\\AndroidStudioProjects\\YGODB\\log\\lastPriceLoadJSON.txt", false)) {
					writer.write(inline);
				}

				YGOLogger.info("Finished reading from API");

				//start timer
				long startTime = System.currentTimeMillis();

				JsonNode cards = jsonNode.get(Const.YGOPRO_TOP_LEVEL_DATA);

				Map<String, List<GamePlayCard>> gamePlayCardMap = DatabaseHashMap.getGamePlayCardsInstance(db);
				ArrayList<OwnedCard> ownedCardsToCheck = db.getAllOwnedCardsWithoutPasscode();

				for (JsonNode currentGamePlayCard : cards) {

					String name = Util.getStringOrNull(currentGamePlayCard, Const.YGOPRO_CARD_NAME);
					int passcode = Util.getIntOrNegativeOne(currentGamePlayCard, Const.YGOPRO_CARD_PASSCODE);

					name = Util.checkForTranslatedCardName(name);
					passcode = Util.checkForTranslatedPasscode(passcode);
					String logIdentifier =  name+ ":" + passcode;

					JsonNode sets = null;
					Iterator<JsonNode> setIterator = null;

					sets = currentGamePlayCard.get(Const.YGOPRO_CARD_SETS);

					List<GamePlayCard> existingGamePlayCards = gamePlayCardMap.get(String.valueOf(passcode));
					if(existingGamePlayCards == null || existingGamePlayCards.isEmpty()){
						existingGamePlayCards = gamePlayCardMap.get(name);
					}
					if(existingGamePlayCards != null && existingGamePlayCards.size() > 1){
						YGOLogger.error("More than one matching gamePlayCard for:" + logIdentifier);
					}

					if (sets != null) {

						if(existingGamePlayCards == null || existingGamePlayCards.isEmpty() ||
								(existingGamePlayCards.size() == 1 && Const.ARCHETYPE_AUTOGENERATE.equals(existingGamePlayCards.get(0).getArchetype()))){
							//no gameplay card, create
							YGOLogger.error("Creating gameplaycard here for:"+logIdentifier);
							GamePlayCard inserted = Util.insertGameplayCardFromYGOPRO(currentGamePlayCard, ownedCardsToCheck, db);

							setIterator = sets.iterator();
							Util.insertOrIgnoreCardSetsForOneCard(setIterator, inserted.getCardName(), inserted.getGamePlayCardUUID(), db);
						}
						else {
							setIterator = sets.iterator();
							updateCardSetsForOneCard(setIterator, name, db);
						}
					}
					else{
						if(existingGamePlayCards != null && existingGamePlayCards.size() == 1 &&
								Const.ARCHETYPE_AUTOGENERATE.equals(existingGamePlayCards.get(0).getArchetype())){
							//autogenerated value exists
							YGOLogger.error("updating autogenerated gameplaycard here for:"+logIdentifier);
							Util.insertGameplayCardFromYGOPRO(currentGamePlayCard, ownedCardsToCheck, db);
						}

					}

				}

				List<String> namesList = new ArrayList<>(nameUpdateMap.keySet());

				for (String setName : namesList) {
					YGOLogger.debug("Possibly need to handle set name issue count: " + nameUpdateMap.get(setName).size() + " " + setName);

					for (int j = 0; j < nameUpdateMap.get(setName).size(); j++) {
						YGOLogger.debug(nameUpdateMap.get(setName).get(j));
					}

				}

				//TODO address keys updated more than once
				// often only difference is in set url
				// color variants
				// limited, unlimited, and first edition entries existing at same time
				// card name erratas being wierd
				// alt arts
				for (String key : updatedMoreThanOnceKeysMap.keySet()) {
					YGOLogger.info("Key updated more than once:" + key);
				}

				Map<String, List<CardSet>> rarityHashMap = DatabaseHashMap.getRaritiesInstance(db);

				for(Map.Entry<String, Set<String>> e: updatedKeysMap.entrySet()){
					String key = e.getKey();
					Set<String> urlsSet = e.getValue();
					ArrayList<String> urlsList = new ArrayList<>(urlsSet);

					if(urlsSet.size() == 1){
						YGOLogger.info("Ready to update set URL:" + key + ":" + urlsList.get(0));

						List<CardSet> listToUpdate = rarityHashMap.get(key);

						if(listToUpdate == null || listToUpdate.size() != 1 ){
							YGOLogger.error("Hashmap missing entry before updating url:" + key);
						}
						else{
							CardSet updateTarget = listToUpdate.get(0);
							db.updateCardSetUrl(updateTarget.getSetNumber(), updateTarget.getSetRarity(),
									updateTarget.getSetName(), updateTarget.getCardName(), urlsList.get(0), null);
						}

					} else {
						YGOLogger.info("Multiple set urls to update for key:" + key);
						attemptToInsertColorVariantsForUrls(key, urlsList, db);
					}
				}

				long endTime = System.currentTimeMillis();
				YGOLogger.info("Time to load data to DB:" + Util.millisToShortDHMS(endTime - startTime));

			}
		} catch (Exception e) {
			YGOLogger.logException(e);
		}
		//end timer
		return true;
	}

	public void attemptToInsertColorVariantsForUrls(String key, List<String> urlsList, SQLiteConnection db) throws SQLException {
		if(key == null || key.isBlank() || urlsList == null || urlsList.size() < 2){
			YGOLogger.error("Invalid input passed to attemptToInsertColorVariantsForUrls" + key + urlsList);
			return;
		}

		Map<String, List<CardSet>> rarityHashMap = DatabaseHashMap.getRaritiesInstance(db);

		List<CardSet> existingList = rarityHashMap.get(key);

		if(existingList == null || existingList.size() != 1){
			YGOLogger.error("No existing row found for key" + key + urlsList);
			return;
		}

		CardSet existingEntry = existingList.get(0);

		//identify colors in urls
		//if there is exactly one url left, assume it is the default color
		//if there are no urls left, update the original

		//if there are more than one url that can't be identified, log an error and do nothing

		Map<String, Integer> colorCount = new HashMap<>();
		String defaultColor = null;
		Map<String, String> urlColors = new HashMap<>(); // To store the identified color for each URL.

		for (String url : urlsList) {
			String color = extractColorFromUrl(url);

			if (color.equals(Const.DEFAULT_COLOR_VARIANT)) {
				if (defaultColor != null) {
					YGOLogger.error("Multiple default colors found. Cannot proceed.");
					return;
				}
				defaultColor = color;
			} else {
				colorCount.put(color, colorCount.getOrDefault(color, 0) + 1);
				if (colorCount.get(color) > 1) {
					YGOLogger.error("Multiple URLs with the same color found. Cannot proceed.");
					return;
				}
			}

			urlColors.put(url, color); // Store the identified color for each URL.
		}

		if (colorCount.size() + (defaultColor != null ? 1 : 0) != urlsList.size()) {
			YGOLogger.error("Some URLs don't have a unique color or default color. Cannot proceed.");
			return;
		}

		// At this point, all URLs have a unique color or a unique color with one default color.
		YGOLogger.info("All URLs have a unique color or a unique color with one default color. Proceeding...");

		boolean first = true;
		String lastColor = null;
		String lastURL = null;
		boolean foundDefault = false;

		// Further processing logic with the urlColors map goes here...
		for (Map.Entry<String, String> entry : urlColors.entrySet()) {
			String url = entry.getKey();
			String color = entry.getValue();
			YGOLogger.info("URL: " + url + ", Identified Color: " + color);

			if(first){
				first = false;
				lastColor = color;
				lastURL = url;
			}
			else{
				if(Const.DEFAULT_COLOR_VARIANT.equals(color)){
					foundDefault = true;
				}

				handleUrlColorUpsert(db, existingEntry, color, url);
			}
		}

		handleUrlColorUpsertLast(db, existingEntry, lastColor, lastURL, foundDefault);
	}

	private void handleUrlColorUpsert(SQLiteConnection db, CardSet existingEntry, String color, String url) throws SQLException {
		if(Const.DEFAULT_COLOR_VARIANT.equals(color)){
			//update existing record with new url
			YGOLogger.info("Updating existing entry to URL:" + url);
			db.updateCardSetUrl(existingEntry.getSetNumber(), existingEntry.getSetRarity(),
					existingEntry.getSetName(), existingEntry.getCardName(), url, null);
		}
		else{
			//insert new record
			YGOLogger.info("adding new entry for "+color+" with URL:" + url);
			db.insertOrIgnoreIntoCardSet(existingEntry.getSetNumber(), existingEntry.getSetRarity(), existingEntry.getSetName(), existingEntry.getGamePlayCardUUID(),
					existingEntry.getCardName(), color, url);
		}
	}

	private void handleUrlColorUpsertLast(SQLiteConnection db, CardSet existingEntry, String color, String url, boolean previouslyFoundDefault) throws SQLException {
		if(previouslyFoundDefault){
			//insert new record
			YGOLogger.info("adding new entry for "+color+" with URL:" + url);
			db.insertOrIgnoreIntoCardSet(existingEntry.getSetNumber(), existingEntry.getSetRarity(), existingEntry.getSetName(), existingEntry.getGamePlayCardUUID(),
					existingEntry.getCardName(), color, url);
		}
		else{
			//update existing record to whatever the remaining color is
			YGOLogger.info("Updating existing entry to "+color+" with URL:" + url);
			db.updateCardSetUrlAndColor(existingEntry.getSetNumber(), existingEntry.getSetRarity(),
					existingEntry.getSetName(), existingEntry.getCardName(), url, null, color);
		}

	}

	// Helper method to extract color information from the URL.
	private static String extractColorFromUrl(String url) {
		String tester = url.replace("blue-eyes","").replace("red-eyes","").replace("eyes-of-blue","");

		if(tester.contains("-red")){
			return "r";
		}
		if(tester.contains("-blue")){
			return "b";
		}
		if(tester.contains("-green")){
			return "g";
		}
		if(tester.contains("-purple")){
			return "p";
		}
		if(tester.contains("-bronze")){
			return "brz";
		}
		if(tester.contains("-silver")){
			return "s";
		}
		if(tester.contains("-alternate-art")){
			return "a";
		}

		return Const.DEFAULT_COLOR_VARIANT;
	}

	public void updateCardSetsForOneCard(Iterator<JsonNode> setIterator, String cardName, SQLiteConnection db)
			throws SQLException {

		while (setIterator.hasNext()) {

			JsonNode currentSet = setIterator.next();
			updateSingleCardSet(cardName, db, currentSet);
		}
	}

	private void updateSingleCardSet(String cardName, SQLiteConnection db, JsonNode setNode) throws SQLException {
		String setNumber = null;
		String setName = null;
		String setRarity = null;
		String setPrice = null;
		String cardEdition = null;
		String setUrl = null;

		try {
			setNumber = Util.getStringOrNull(setNode, Const.YGOPRO_SET_CODE);
			setName = Util.getStringOrNull(setNode, Const.YGOPRO_SET_NAME);
			setRarity = Util.getStringOrNull(setNode, Const.YGOPRO_SET_RARITY);
			setPrice = Util.getStringOrNull(setNode, Const.YGOPRO_SET_PRICE);
			cardEdition = Util.getStringOrNull(setNode, Const.YGOPRO_CARD_EDITION);
			setUrl = Util.getStringOrNull(setNode,Const.YGOPRO_SET_URL);

			//String set_rarity_code = Util.getStringOrNull(setNode,"set_rarity_code");

		} catch (Exception e) {
			YGOLogger.info("issue found on " + cardName);
			return;
		}
		if (cardEdition == null) {
			cardEdition = "";
		}

		boolean isFirstEdition = cardEdition.contains(Const.CARD_PRINTING_CONTAINS_FIRST);

		setRarity = Util.checkForTranslatedRarity(setRarity);
		setName = Util.checkForTranslatedSetName(setName);
		setNumber = Util.checkForTranslatedSetNumber(setNumber);

		List<String> translatedList = Util.checkForTranslatedQuadKey(cardName, setNumber, setRarity, setName);
		cardName = translatedList.get(0);
		setNumber = translatedList.get(1);
		setRarity = translatedList.get(2);
		setName = translatedList.get(3);

		setPrice = Util.normalizePrice(setPrice);

		if(Util.getSetUrlsThatDontExistInstance().contains(setUrl)){
			return;
		}

		if (setPrice != null && !setPrice.equals(Const.ZERO_PRICE_STRING)) {
			int rowsUpdated = updatePriceUsingMultipleStrategiesWithHashmap(cardName, db, setNumber, setName, setRarity, setPrice, isFirstEdition, setUrl);
			if (rowsUpdated != 1) {
				YGOLogger.info(OPEN + setNumber + SEP + cardName + SEP + setRarity +
						SEP + setName + CLOSE + setPrice + "," + rowsUpdated + " rows updated");
			}
		}

		//bow out early if we don't have a set url to test
		if(setUrl == null || setUrl.isBlank()){
			return;
		}

		//keep track of all entries in sets for updating set url
		Map<String, List<CardSet>> rarityHashMap = DatabaseHashMap.getRaritiesInstance(db);

		List<CardSet> urlKeysMatched = rarityHashMap.get(setUrl);

		if(urlKeysMatched == null || urlKeysMatched.isEmpty()){
			//no matching url key, log
			CardSet matcherInput = new CardSet();
			matcherInput.setSetRarity(setRarity);
			matcherInput.setSetNumber(setNumber);
			matcherInput.setCardName(cardName);
			matcherInput.setSetName(setName);
			//url intentionally blank

			String allMatchUrlKey = DatabaseHashMap.getAllMatchingKeyWithUrl(matcherInput);

			List<CardSet> existingRows = rarityHashMap.get(allMatchUrlKey);

			if(existingRows != null && existingRows.size() == 1){
				CardSet existingRowWithNullUrl = existingRows.get(0);
				addToUpdatedKeysMap(DatabaseHashMap.getAllMatchingKey(existingRowWithNullUrl), setUrl);
			}
			else{
				existingRows = rarityHashMap.get(DatabaseHashMap.getSetNameMismatchKeyWithUrl(matcherInput));

				if(existingRows != null && existingRows.size() == 1){
					CardSet existingRowWithNullUrl = existingRows.get(0);
					addToUpdatedKeysMap(DatabaseHashMap.getAllMatchingKey(existingRowWithNullUrl), setUrl);
				}
				else {

					int size = 0;

					if(existingRows != null){
						size = existingRows.size();
					}

					String cardLogIdentifier = OPEN + setNumber + SEP + cardName + SEP + setRarity + SEP + setName + CLOSE + setPrice;

					YGOLogger.error("Found "+size+" matches for all matching url key:" + allMatchUrlKey + ":"+cardLogIdentifier);
				}
			}

		}
		else if(urlKeysMatched.size() > 1){
			YGOLogger.error("More than one matching key for url:" + setUrl);
		}
		//if exactly one, we don't want to update it

	}

	private int updatePriceUsingMultipleStrategiesWithHashmap(String cardName, SQLiteConnection db, String setNumber, String setName,
															  String setRarity, String setPrice, boolean isFirstEdition, String setURL) throws SQLException {

		Map<String, List<CardSet>> rarityHashMap = DatabaseHashMap.getRaritiesInstance(db);
		CardSet matcherInput = new CardSet();
		matcherInput.setSetRarity(setRarity);
		matcherInput.setSetNumber(setNumber);
		matcherInput.setCardName(cardName);
		matcherInput.setSetName(setName);
		String cardLogIdentifier = OPEN + setNumber + SEP + cardName + SEP + setRarity + SEP + setName + CLOSE + setPrice;

		//check by set url first

		if(setURL != null && !setURL.isBlank()) {
			List<CardSet> existingRows = rarityHashMap.get(setURL);
			if (existingRows != null && !existingRows.isEmpty()) {
				if (existingRows.size() > 1) {
					// more than 1 exact match, color or art variant
					YGOLogger.error("more than 1 exact match for set url:" + setURL);
				}

				db.updateCardSetPriceBatchedByURL(setPrice, setURL, isFirstEdition);

				for (CardSet set : existingRows) {
					addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
				}
				return existingRows.size();
			}
		}

		List<CardSet> existingRows = rarityHashMap.get(DatabaseHashMap.getAllMatchingKey(matcherInput));
		if (existingRows != null && !existingRows.isEmpty()) {
			if (existingRows.size() > 1) {
				// more than 1 exact match, color or art variant
				YGOLogger.error("more than 1 exact match, color or art variant:" + cardLogIdentifier);
			}

			db.updateCardSetPriceBatchedWithCardAndSetName(setNumber, setRarity, setPrice, setName, cardName, isFirstEdition);

			for (CardSet set : existingRows) {
				addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
			}
			return existingRows.size();
		}

		existingRows = rarityHashMap.get(DatabaseHashMap.getSetNameMismatchKey(matcherInput));
		if (existingRows != null && !existingRows.isEmpty()) {
			if (existingRows.size() > 1) {
				YGOLogger.error("Multiple rows updated for set name mismatch from price API:" + cardLogIdentifier);
			}
			db.updateCardSetPriceBatchedWithCardName(setNumber, setRarity, setPrice, cardName, isFirstEdition);
			List<String> setNamesList = nameUpdateMap.computeIfAbsent(setName, k -> new ArrayList<>());
			setNamesList.add(cardName + " " + setNumber);

			for (CardSet set : existingRows) {
				addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
			}
			return existingRows.size();
		}

		existingRows = rarityHashMap.get(DatabaseHashMap.getCardNameMismatchKey(matcherInput));
		if (existingRows != null && !existingRows.isEmpty()) {
			if (existingRows.size() > 1) {
				YGOLogger.error("Multiple rows updated for card name mismatch from price API:" + OPEN + setNumber + SEP + cardName + SEP + setRarity +
						SEP + setName + CLOSE + setPrice);
			}
			YGOLogger.debug("Card name mismatch from price API:" + cardLogIdentifier);

			int rowsUpdated = db.updateCardSetPriceWithSetName(setNumber, setRarity, setPrice, setName, isFirstEdition);
			if (rowsUpdated != existingRows.size()) {
				YGOLogger.error("Actual rows updated did not equal predicted for card name mismatch" + cardLogIdentifier);
			}
			for (CardSet set : existingRows) {
				addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
			}
			return rowsUpdated;
		}

		existingRows = rarityHashMap.get(DatabaseHashMap.getCardAndSetNameMismatchKey(matcherInput));
		if (existingRows != null && !existingRows.isEmpty()) {
			if (existingRows.size() > 1) {
				YGOLogger.error("Multiple rows updated for card and set name mismatch from price API:" + cardLogIdentifier);
			}
			int rowsUpdated = db.updateCardSetPrice(setNumber, setRarity, setPrice, isFirstEdition);
			YGOLogger.info("Card name mismatch from price API:" + cardLogIdentifier);
			List<String> setNamesList = nameUpdateMap.computeIfAbsent(setName, k -> new ArrayList<>());
			setNamesList.add(cardName + " " + setNumber);
			if (rowsUpdated != existingRows.size()) {
				YGOLogger.error("Actual rows updated did not equal predicted for card and set name mismatch" + cardLogIdentifier);
			}
			for (CardSet set : existingRows) {
				addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
			}
			return rowsUpdated;
		}

		existingRows = rarityHashMap.get(DatabaseHashMap.getSetNumberOnlyKey(matcherInput));
		if (existingRows != null && existingRows.size() == 1) {
			int rowsUpdated = db.updateCardSetPrice(setNumber, setPrice, isFirstEdition);
			YGOLogger.info("Card rarity mismatch from price API:" + cardLogIdentifier);
			if (rowsUpdated != 1) {
				YGOLogger.error("Actual rows updated did not equal predicted for card rarity mismatch" + cardLogIdentifier);
			}
			for (CardSet set : existingRows) {
				addToSetAndMap(DatabaseHashMap.getAllMatchingKeyWithUrl(set) + isFirstEdition);
			}
			return rowsUpdated;
		}
		//multiple options or zero are possible for setNumber, so don't update anything
		return 0;
	}

	private void addToUpdatedKeysMap(String key, String urlAdded) {

		Set<String> list = updatedKeysMap.computeIfAbsent(key, k -> new HashSet<>());

		list.add(urlAdded);
	}

	private void addToSetAndMap(String key) {
		if (updatedKeysSet.contains(key)) {
			updatedMoreThanOnceKeysMap.merge(key, 1, Integer::sum);
		} else {
			updatedKeysSet.add(key);
		}
	}
}